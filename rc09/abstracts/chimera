Эффективное управление сторонним ПО под *nix: теория и практика
----
Сегодня ни одна информационная система не обходится без сторонних приложений. От спутников и марсоходов, видеокамер и mp3-плееров, до маршрутизаторов, серверов, ИБП и файловых массивов, - любое устройство несёт на борту тесно интегрированный набор программ от разных разработчиков. Алгоритмическая сложность повседневных вычислительных задач давно превысила потенциал отдельно взятого поставщика ПО, даже если это огромная корпорация. И пока эта сложность будет расти, вместе с ней будет увеличиваться количество установленных программ, вызываемых библиотек и запущенных процессов на компьютере.

Управление и взаимодействие со сторонним ПО - основополагающая функция современной ОС. Для пользователей это запуск и работа с приложениями, обмен данными между ними, для администраторов - сборка и установка пакетов, их обновление и настройка, для производителей ОС и аппаратных решений - интеграция сторонних библиотек и утилит в среду разработки и саму систему, их документация и поддержка на одном уровне с остальными компонентами.

В докладе рассмотрен обширный круг проблем, с которыми сталкиваются инженеры и операторы при управлении приложениями. Представлены решения этих задач в разных ОС в исторической и текущей перспективах. Изучены возможные пути эволюции на фоне развития базовых компонентов *nix-систем. Показано значение тонкой виртуализации, разграничения ресурсов и ролевого доступа для компартментализации ПО. Описаны интересные экспериментальные проекты, планы разработчиков популярных ОС.

Практическая часть доклада на примере использования технологических решений проекта FreeBSD детально раскрывает общие методы и частные приёмы управления сторонним ПО в виде портов и пакетов. В качестве наглядных иллюстраций в стиле tips & tricks представлены работа со стандартными утилитами и скриптами, построение корпоративной инфраструктуры, диагностика и исправление различных ошибок, предварительный анализ обновлений, бекап и откат, проверка состояния установленных приложений, отслеживание и решение проблем с библиотеками, и т.д. Большинство предложенных методов находят применение в любой Unix-подобной системе.

Задача доклада в целом - с разных сторон осветить проблему управления ПО. От крупномасштабной картины в разрезах времени и сфер применения до конкретики на уровне отдельной ОС - доклад охватывает широкий диапазон тем, обращая внимание как на долгосрочные тенденции и возможные стратегии, так и на современную специфическую практику управления ПО, предлагая привычки и методы, существенно облегчающие жизнь системным администраторам и архитекторам.
----

Skeleton

Sharing and interfacing

Types of resources
 per-package sharing rationale

CPU
 CPU time
 the price of context-switching
  threading vs cores
  scheduler complexity

RAM
 time
 throughput
  overshadowed by CPU time?

HDD
 space
  qoutas
  user data
  cross-app data
 throughput
  geom

Namespaces
 File System
  multi-versioning
   per-user
   block-based
 User names
 Group names

Networking
 protocols
 ports
 throughput
 runtime, firewall

Generalized Access Control
 DAC, MAC, RSBAC
 SELinux, AppArmor, TrustedBSD, Systrace, Symbian

Trust
 Digital Signatures
  WHQL, Apple, Symbian, Gaming Consoles, Tivoization

Virtualization
 heavy context-switching
  mitigated somewhat by new CPU functions
 vs multi-core
 mainframe approach
  dedicated channels

Security Domains
 local timing attacks
 attacks on randomness

GUI
 X11 tiling
 priority

User Attention
 real world alert practices
  5 sense, two usable
 text interfaces, text output
  standing out, collapsing

Types of interfacing
 API
 ABI
 higher abstractions
 protocols
 serialisation
 IPC
  shared memory, etc

Shared libs
 Binary
 Scripted
 Cache-compiled
 Symbol versioning

Shared data
 concurrency
 real-time collaboration

Quality Assurance

Feedback collection
 backtraces

Tracking Upstream
 necessity of open/shared source
 local VCS
 regression testing infrastructure
 ubiquitous automation
 versiontracker for windows
---------------

Sharing
 NFS
 separate /usr/distfiles
 RO /usr/ports
 RW /usr/distfiles
 fetch-all RO /usr/distfiles
  multi-threaded shell scripting

Build-machines
  
Updates
 changelog
 user reaction
 source diff inspection
  ardiff
 
Portsnap
 proxy quirks
 caching

shlibs
 libmap
 compat
 system libs

monitoring portupgrade
 temp files
 pgrep -fl portupgrade
 logs

System upgrades

Portupgrades
 ruby, bdb
====TXTTXT====

---+ Теория

Ещё не так давно стороннего ПО просто не было. Сегодня каждый мобильный телефон использует сторонние разработки. Это 4 миллиарда устройств. Каждый из миллиарда персональных компьютеров несёт на борту десятки продуктов от совершенно разных поставщиков. Несложно представить себе масштабы проблем, возникающих при интеграции приложений с системами.

Многие современные ОС, например, популярные дистрибутивы GNU/Linux практически целиком состоят из раздельно развиваемых программных пакетов, стирая грани между основной системой и сторонней её частью. Такие ОС, как Windows и FreeBSD, представляют пользователям цельный набор из ядра и десятков системообразующих приложений. Но на самом деле эти цельные ОС лишь более тесно интегрируют аналогичное ПО в систему и процесс разработки и не так сильно отличаются от парадигмы линукса, как может показаться. Так или иначе, доклад не ставит целью отделить стороннее ПО от внутрисистемного, так как граница эта с каждым годом всё более размыта, а проблемы управления абсолютно одинаковые, независимо от статуса приложения в отдельно взятой системе.

---++ Управление ПО

Управление ПО за 20 лет из небольшого набора привычных действий выросло в ряд огромных процветающих отраслей. И каждый день мы видим, что это только начало. Взрывные успехи Apple App Store и Valve Steam намекают на неизведанный гигантский потенциал лишь на однои из рынков - платформ распространения.

В общем смысле всё, что происходит от появления идеи у разработчика в голове до готового результата работы компьютера у пользователя, - весь жизненный цикл программных продуктов подразумевает организацию и управление. Ниже рассмотрены лишь несколько относительно узких и вместе с тем довольно больших и сложных проблем, которые, во-первых, могут быть интересны системным администратором, и, во-вторых, представляют собой направления интенсивного горизонтального и вертикального развития систем управления пакетами в *nix и аналогичных подсистем в других ОС.

На данный момент пересечением функциональности большинства пакетных менеджеров является скачивание пакета из сети, сборка при необходимости, распаковка в файловую систему и удаление.

Управление материальными и абстрактными ресурсами, взаимодействие между программами, представление хода разработки в виде дозированных обновлений при контроле качества.

---+++ Ресурсы
---+++ Интерфейсы
---+++ Обновления

---+ Практика

Каждый раз, когда приходит время пополнять или обновлять набор установленных программ, администратор проходит один и тот же порочный круг: подготовка к процессу, в ходе которой выявляются возможные грабли и пути их обхода, собственно процесс, который неизбежно включает в себя наступание на все выявленные грабли, и заключающую стадию - устранение последствий. Если вам посчастливилось оказаться один на один с ОС FreeBSD, то в трудной ситуации общий совет один: DON'T PANIC! Порты устроены так, что какие бы ошибки ни возникали, в большинстве случаев вы сможете устранить критические неполадки в течение нескольких минут, если, конечно, трепетное отношение к делу не заставит вас пытаться одновременно переустановить систему, восстановиться из бекапа полугодовалой давности и слепо испробовать все советы из первых ста результатов гугла на панически составленный запрос в стиле "ничего не работает!"

Но начнём с подготовки. Главной залог успешной работы с ПО - участие в сообществе. Как минимум перед очередной установкой или апгрейдом важной программы необходимо просмотреть списки рассылки и форумы, как по самой программе, так и по ОС, под которой она должна заработать. При работе с системами статуса mission-critical или 24/7, даже при использовании собственных тестово-отладочных стендов, лучше быть подписанным и с интересом читать рассылки. В случае FreeBSD это ports@FreeBSD.org, а также специализированные списки типа apache@, perl@ и x11@, плюс рассылки по самим продуктам, такие как users@httpd.apache.org и xorg@lists.freedesktop.org.

Даже пассивное участие в комьюнити не только предостережёт вас от известных ошибок, но и позволит бесплатно использовать чужой опыт для совершенствования ваших систем. Часто изучению открытых ресурсов препятствует языковой барьер, а аналогичные русскоязычные сообщества несут информацию на порядки меньших объёмов. Что ж, здесь помогут лишь онлайн-переводчик и хороший учебник. Для работы со свободным ПО лучше всего подходит английский язык, с варезом - китайский, с лицензионным закрытым софтом - язык маркетологов (в разы превышающий по сложности первые два вместе взятые).

Итак, после участия в комьюнити или отказа от него в пользу более приятного времяпрепровождения на слешдоте или хабре, следующий шаг - изучить последние изменения, внесённые как в само ПО, так и в метаданные, интегрирующие его с ОС. Под FreeBSD вам следует внимательно посмотреть на коммит-лог порта и в файл /usr/ports/UPDATING. И лог, и записи из этого файла для неискушённых в шелле администраторов удобней всего увидеть на сайте www.freshports.org.
